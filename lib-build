#!/usr/bin/env node
const path = require("path");
const fs = require("fs");
const crypto = require("crypto");
const CommandLine = require('./lib/CommandLine');
const CmakeBuild = require("./lib/CMake");
const Platform = require("./lib/Platform");
const Utils = require('./lib/Utils');
const LibraryTool = require("./lib/LibraryTool");

const optionDeclarations = [
    {
        name: "source",
        shortName: "s",
        type: "string",
        description: "Specify the project source path."
    },
    {
        name: "output",
        shortName: "o",
        type: "string",
        description: "Specify the library output path."
    },
    {
        name: "platform",
        shortName: "p",
        type: "string",
        description: "Specify the current platform. Supported platforms: [\"win\", \"mac\", \"ios\", \"linux\", \"android\", \"web\"]."
    },
    {
        name: "debug",
        shortName: "d",
        type: "boolean",
        description: "Build with debug mode enabled."
    },
    {
        name: "arch",
        shortName: "a",
        type: "string",
        description: "Builds the specified arch only. Supported archs: [\"x86\", \"x64\", \"arm\", \"arm64\", \"arm64-simulator\", \"wasm\"]. Ignored if --xcframework is specified."
    },
    {
        name: "incremental",
        shortName: "i",
        type: "boolean",
        description: "Uses incremental build. The build directory will not be removed after the building finished."
    },
    {
        name: "xcframework",
        shortName: "x",
        type: "boolean",
        description: "Merges all archs of the output libraries into one xcframework if current platform supports it."
    },
    {
        name: "native",
        shortName: "n",
        type: "boolean",
        description: "Use the native generator with cmake to build the library if current platform supports it. Set to true if --xcframework is specified."
    },
    {
        name: "help",
        shortName: "h",
        type: "boolean",
        description: "Print help message."
    }
];

function printHelp(cmd) {
    let output = "";
    output += "Syntax:   " + cmd + " [-Dcmake_variable=value]... [-Dcmake_variable=value] [options]\n";
    output += "Examples: " + cmd + " -p ios -o ./out/ios\n";
    output += "Examples: " + cmd + " --debug\n";
    output += "Examples: " + cmd + " -DTGFX_USE_WEBP_ENCODE=ON -p mac\n";
    output += CommandLine.printOptions(optionDeclarations);
    Utils.log(output);
}

function getHash(options, cmakeArgs) {
    let list = [];
    list.push(options.native ? "native" : "ninja");
    list.push(options.platform);
    list.push(options.debug ? "debug" : "release");
    list = list.concat(cmakeArgs);
    let sourcePath = options.source;
    let targetName = options.targets[0];
    let hashConfigFile = path.resolve(sourcePath, targetName + ".hash");
    let xcHashFiles = [];
    if (fs.existsSync(hashConfigFile)) {
        let hasConfig = Utils.readFile(hashConfigFile);
        let files = hasConfig.split("\n");
        for (let file of files) {
            let filePath = path.resolve(sourcePath, file.trim());
            let fileList = Utils.findFiles(filePath);
            xcHashFiles = xcHashFiles.concat(fileList);
        }
    } else {
        let shallowFile = path.resolve(sourcePath, ".git/shallow");
        let commit = "";
        if (fs.existsSync(shallowFile)) {
            commit = Utils.readFile(shallowFile).trim();
        } else {
            commit = Utils.execSafe("git rev-parse HEAD", sourcePath).trim();
        }
        list.push(commit);
        let diff = Utils.execSafe("git diff --name-only HEAD", sourcePath);
        if (diff) {
            let files = diff.split("\n");
            for (let file of files) {
                let filePath = path.resolve(sourcePath, file.trim());
                xcHashFiles.push(filePath);
            }
        }
    }
    let hash = crypto.createHash('md5')
    let content = list.join("\n");
    hash.update(content)
    for (let filePath of xcHashFiles) {
        hash.update(filePath);
        let fileContent = Utils.readFile(filePath);
        if (fileContent) {
            hash.update(fileContent);
        }
    }
    return hash.digest('hex')
}

function buildArch(options, cmakeArgs, platform, versionHash, message) {
    let targetName = options.targets[0];
    let arch = platform.archs[0];
    let buildType = platform.buildType.toLowerCase();
    let sourcePath = options.source;
    let outPath = options.output;
    let xcHashFile = path.join(outPath, "." + targetName + "." + arch + ".md5");
    let currentHash = Utils.readFile(xcHashFile);
    if (!options.xcframework && versionHash === currentHash) {
        return false;
    }
    Utils.deletePath(xcHashFile);
    currentHash = versionHash;
    let cmakeOptions = {};
    cmakeOptions.targets = [targetName];
    cmakeOptions.arguments = cmakeArgs;
    cmakeOptions.incremental = true;
    cmakeOptions.native = options.native;
    if (message) {
        Utils.log(message);
    }
    let cmake = CmakeBuild.Create(platform);
    cmake.build(sourcePath, outPath, cmakeOptions);
    if (currentHash) {
        Utils.writeFile(xcHashFile, currentHash);
    }
    return true;
}

let args = process.argv;
let execPath = path.resolve(process.argv[1]);
let isCustomBuild = execPath !== __filename;
let cmd = "node " + path.basename(args[1]);
args = args.slice(2);
let cmakeArgs = [];
let cmdArgs = [];
for (let arg of args) {
    if (arg.indexOf("-D") === 0) {
        cmakeArgs.push(arg);
    } else {
        cmdArgs.push(arg);
    }
}
let options = CommandLine.parse(cmdArgs, optionDeclarations);
if (!options.source) {
    if (isCustomBuild) {
        options.source = path.dirname(execPath);
    } else {
        options.source = process.cwd();
    }
} else {
    options.source = path.resolve(options.source);
}
if ((!options.targets || options.targets.length === 0) && isCustomBuild) {
    let basename = path.basename(process.argv[1]);
    let target = "";
    if (basename.endsWith("-build") || basename.endsWith("_build")) {
        target = basename.substring(0, basename.length - 6);
    } else if (basename.startsWith("build-") || basename.startsWith("build_")) {
        target = basename.substring(6);
    }
    if (target) {
        options.targets = [target];
    }
}
if (!options.targets || options.targets.length !== 1) {
    options.help = true;
}
if (options.help) {
    printHelp(cmd);
    if (options.errors.length > 0) {
        process.exit(1);
    }
    return;
}
if (!options.debug) {
    if (process.env["VENDOR_BUILD_TYPE"] === "Debug") {
        options.debug = true;
    }
}
let platform = Platform.Create(options.platform, options.debug, true);
if (options.xcframework && options.arch) {
    delete options.arch;
    options.native = true;
}
if (options.arch) {
    platform.setArch(options.arch);
}
let targetName = options.targets[0];
let buildType = platform.buildType.toLowerCase();
if (!options.output) {
    options.output = path.resolve(options.source, "out", buildType, platform.name);
} else {
    options.output = path.resolve(options.output);
}

let startMessage = "====================== build " + targetName + "-" + platform.name + "-" +
    buildType + " start ======================";
startMessage += "\n[Source]: " + options.source;
startMessage += "\n[Output]: " + options.output;
let versionHash = getHash(options, cmakeArgs);
let xcHashFile = path.join(options.output, "." + targetName + ".xcframework.md5");
let currentXCHash = "";
if (options.xcframework) {
    currentXCHash = Utils.readFile(xcHashFile);
    if (versionHash === currentXCHash) {
        return;
    }
    Utils.deletePath(xcHashFile);
}
if (!options.incremental) {
    Utils.deletePath(path.join(options.output, "build-" + targetName));
}
let archs = platform.archs;
for (let arch of archs) {
    platform.archs = [arch];
    if (buildArch(options, cmakeArgs, platform, versionHash, startMessage)) {
        startMessage = "";
    }
}
platform.archs = archs;

if (options.xcframework) {
    if (startMessage) {
        Utils.log(startMessage);
        startMessage = "";
    }
    currentXCHash = versionHash;
    let libraryTool = LibraryTool.Create(platform);
    libraryTool.createXCFramework(options.output, options.output, false, true, function (library) {
        let ext = path.extname(library);
        let name = path.parse(library).name;
        return ext && name.indexOf(targetName) !== -1;
    });
    if (currentXCHash) {
        Utils.writeFile(xcHashFile, currentXCHash);
    }
}

if (!options.incremental) {
    Utils.deletePath(path.join(options.output, "build-" + targetName));
}

if (!startMessage) {
    Utils.log("====================== build " + targetName + "-" + platform.name + "-" +
        buildType + " end ======================");
}
